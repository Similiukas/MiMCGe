use std::fmt;
use std::fmt::Formatter;
use crate::utils::helpers::{add_finite_field, Cipher, FieldElement, generate_round_constants, power_finite_field, to_decimal};

pub struct MiMC {
    block_size: u32,
    field: u128,
    rounds: usize,
    round_constants: Vec<FieldElement>
}

impl MiMC {
    pub fn new(block_size: u32) -> Self {
        let rounds = (block_size as f32 / 3f32.log(2.0)).ceil() as usize;
        MiMC::with_round_constants(block_size, &generate_round_constants(rounds, block_size))
    }

    pub fn with_round_constants(block_size: u32, round_constants: &Vec<FieldElement>) -> Self {
        // For field 2 ^ block_size it must be that block_size is odd
        assert_eq!(block_size % 2, 1, "Block size must be odd");
        MiMC {
            block_size,
            field: 2u128.pow(block_size),
            rounds: round_constants.len(),
            round_constants: round_constants.to_vec()
        }
    }
}

impl Cipher for MiMC {
    fn encrypt(&self, plaintext: &FieldElement, key: &FieldElement) -> FieldElement {
        let mut state: FieldElement = plaintext.to_vec();
        for round in 0..self.rounds {
            let mut temp= add_finite_field(&key, &self.round_constants[round]);
            temp = add_finite_field(&state, &temp);
            state = power_finite_field(&temp, 3, self.block_size);
        }
        add_finite_field(&state, &key)
    }

    fn decrypt(&self, ciphertext: &FieldElement, key: &FieldElement) -> FieldElement {
        assert!(self.block_size <= 31, "Decryption for 2^31 field is not implemented (too slow)");
        let mut state: FieldElement = ciphertext.to_vec();
        let power = (2usize.pow(self.block_size + 1) - 1) / 3;
        for round in self.round_constants[..1].iter().chain(self.round_constants[1..].iter().rev()) {
            let mut temp = add_finite_field(&key, round);
            temp = add_finite_field(&state, &temp);
            state = power_finite_field(&temp, power, self.block_size);
        }
        add_finite_field(&state, &key)
    }
}

impl fmt::Display for MiMC {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let converted_rc: &Vec<u128> = &self.round_constants.iter().map(|x| to_decimal(x)).collect();

        f.debug_struct("MiMC")
            .field("\n  block size", &self.block_size)
            .field("\n  rounds", &self.rounds)
            .field(&*format!("\n  field [2^{}]", &self.block_size), &self.field)
            .field("\n  round constants", converted_rc)
            .finish()
    }
}

#[cfg(test)]
mod tests {
    use crate::mimc::mimc::MiMC;
    use crate::utils::helpers::{Cipher, to_binary};

    #[test]
    fn encrypt_small() {
        // 0, 5, 22, 16
        let round_constants = vec![vec![0;5], vec![0,0,1,0,1], vec![1,0,1,1,0], vec![1,0,0,0,0]];
        let cipher = MiMC::with_round_constants(5, &round_constants);
        // Plaintext 15, key 29, ciphertext 7
        assert_eq!(cipher.encrypt(&vec![0,1,1,1,1], &vec![1,1,1,0,1]), vec![0,0,1,1,1]);
    }

    #[test]
    fn decrypt_small() {
        // 0, 5, 22, 16
        let round_constants = vec![vec![0;5], vec![0,0,1,0,1], vec![1,0,1,1,0], vec![1,0,0,0,0]];
        let cipher = MiMC::with_round_constants(5, &round_constants);
        // Ciphertext 7, key 29, plaintext 15
        assert_eq!(cipher.decrypt(&vec![0,0,1,1,1], &vec![1,1,1,0,1]), vec![0,1,1,1,1]);
    }

    #[test]
    fn encrypt_big() {
        // 0, 95538, 91070, 126210, 32213, 108263, 108425, 32325, 51166, 52563, 123364
        let round_constants = vec![vec![0;17], to_binary(95538, 17),
                                   to_binary(91070, 17), to_binary(126210, 17),
                                   to_binary(32213, 17), to_binary(108263, 17),
                                   to_binary(108425, 17), to_binary(32325, 17),
                                   to_binary(51166, 17), to_binary(52563, 17),
                                   to_binary(123364, 17)];
        let cipher = MiMC::with_round_constants(17, &round_constants);
        // Plaintext 29321, key 17597, ciphertext 77574
        assert_eq!(cipher.encrypt(&to_binary(29321, 17), &to_binary(17597, 17)), to_binary(77574, 17));
    }

    #[test]
    fn decrypt_big() {
        // 0, 95538, 91070, 126210, 32213, 108263, 108425, 32325, 51166, 52563, 123364
        let round_constants = vec![vec![0;17], to_binary(95538, 17),
                                   to_binary(91070, 17), to_binary(126210, 17),
                                   to_binary(32213, 17), to_binary(108263, 17),
                                   to_binary(108425, 17), to_binary(32325, 17),
                                   to_binary(51166, 17), to_binary(52563, 17),
                                   to_binary(123364, 17)];
        let cipher = MiMC::with_round_constants(17, &round_constants);
        // Ciphertext 77574, key 17597, plaintext 29321
        assert_eq!(cipher.decrypt(&to_binary(77574, 17), &to_binary(17597, 17)), to_binary(29321, 17));
    }

    #[test]
    fn encrypt_61() {
        let block = 61u32;
        // 0, 917513374301924892, 2197242370239185538, 1835193395707853569, 910406909378922478, 410969177513640493, 1576597906080612601, 1996650878869330522,
        // 1739878200794315314, 1683382698496049428, 1934871567918074588, 1714392371795909343, 827617831275798560, 2052261838712770734, 1603654771883899757,
        // 619127913719619529, 766153077673170924, 694647025981922083, 231233955806834067, 1764572233692870480, 1996923257040947150, 20560689391197468,
        // 714405827524416642, 362656677669385204, 731541335977143361, 1735488281771032550, 551251955048189056, 2151149141796943481, 16088776207804024,
        // 1995984743281408293, 850161300180226751, 745241947920358308, 316880646149103203, 2162527612438725695, 1619713202686280227, 1462908596970427786,
        // 803148614745895423, 2285390318440429285, 1875161608166957759
        let round_constants = vec![vec![0;61], to_binary(917513374301924892, block), to_binary(2197242370239185538, block), to_binary(1835193395707853569, block), to_binary(910406909378922478, block), to_binary(410969177513640493, block), to_binary(1576597906080612601, block), to_binary(1996650878869330522, block),
            to_binary(1739878200794315314, block), to_binary(1683382698496049428, block), to_binary(1934871567918074588, block), to_binary(1714392371795909343, block), to_binary(827617831275798560, block), to_binary(2052261838712770734, block), to_binary(1603654771883899757, block),
            to_binary(619127913719619529, block), to_binary(766153077673170924, block), to_binary(694647025981922083, block), to_binary(231233955806834067, block), to_binary(1764572233692870480, block), to_binary(1996923257040947150, block), to_binary(20560689391197468, block),
            to_binary(714405827524416642, block), to_binary(362656677669385204, block), to_binary(731541335977143361, block), to_binary(1735488281771032550, block), to_binary(551251955048189056, block), to_binary(2151149141796943481, block), to_binary(16088776207804024, block),
            to_binary(1995984743281408293, block), to_binary(850161300180226751, block), to_binary(745241947920358308, block), to_binary(316880646149103203, block), to_binary(2162527612438725695, block), to_binary(1619713202686280227, block), to_binary(1462908596970427786, block),
            to_binary(803148614745895423, block), to_binary(2285390318440429285, block), to_binary(1875161608166957759, block)];
        let cipher = MiMC::with_round_constants(block, &round_constants);
        // Plaintext 768668057857465585, key 1952190691262887842, ciphertext 2242650572909103635
        assert_eq!(cipher.encrypt(&to_binary(768668057857465585, block), &to_binary(1952190691262887842, block)), to_binary(2242650572909103635, block));
    }

    #[test]
    fn encrypt_127() {
        let block = 127u32;
        // 0, 60830615133950554781816095544784746916, 123974209842762307096225067893741045796, 135753353596758349485516658254368525747, 2939595398576264087850956589342439304,
        // 40076352750431212541803900149960257548, 93852482691172964849160854953085040497, 73054168740293751893382319070945114008, 144789746567824501222915256981756980652,
        // 59036272182462320228333616846778978649, 166439991022674764481604851805671696717, 64091962405798025994984400729877468973, 8950317157704596166529150362709421344,
        // 28795834160692336853030883568187811345, 137915742661053200982257724694012736541, 86085925939554565779417794353904662176, 23288358310028615539116789380099884810,
        // 165981077950982094502239969905075428928, 4469287351800280448126894826667641959, 888278832978011390558589191095311509, 123576576783312288673553204116526681366,
        // 38579962837753657712628810806406624638, 7478510915411686125285526311256515365, 47919742180966932354471811295519267460, 142347171677650656168600537099065620459,
        // 105465968464268156221336769206667608062, 166464775595544809388951462027615614390, 137233817427539608459093273965615148811, 44777913530343219558122532298784153232,
        // 94475522280157304513405905985442894506, 78575530189542675168336177243931529836, 115001994014445856801177509366837033576, 59429935103375028870050059594174275954,
        // 20346381335678829430384832000907868512, 11237619622190469976409742019793615286, 151140273109080355090712990319289701265, 93702753531267315032829931483592140707,
        // 58777198280635264403352853681873754441, 151586869306501686780863393969097636077, 156710783721481112692276585985340770102, 120056016483253930210671541690868977863,
        // 156887814104095280194399769496450268073, 146768835735757528552066223178033184782, 65624804534009978967830519884494217981, 436125201163551063098589517560187809,
        // 109800002567224400418779846336130677477, 83513827187087678177766363430713870527, 132988609336594686344463556093200414537, 142366609295053440692582788970203749744,
        // 109387684609525752799508021957504570466, 20933172057947839459182393216063960978, 157323792536550539118094368367362870082, 145677098552381657304860012383218055267,
        // 66784356843727874345536747980169357806, 164948109270748232225299160763320039218, 51438652122929605347730032519583036044, 62212925368486723456904506863637394704,
        // 77062683975205218952024654251715634120, 144781915490232917836800052687357489309, 95379270850067906396539125244481076798, 111359025990301004509455750186474327590,
        // 77390411713043003458557036104010645069, 97887147215960387433298055563163774892, 120905281723079439403682204698227350328, 137463780365100262676644052361004290476,
        // 74901688219653535235259385966176528537, 139523595055809961167957783873928607384, 137372463640221908986201541074832293262, 156840293697636280672410303577981468250,
        // 138066564216439861192551603930676022704, 164168867156173857990648020402791554099, 97479537262841041034787751216352008294, 66945230408801357834244322471887444053,
        // 152442893795360537653719156412267908117, 12292790713563221531272411065878531353, 134375040760238427936311675753868485332, 149592608250844774105720014502350027851,
        // 12319566215008486035364907927680778391, 158711805550223450233018026255709118815, 84020431617253616172384297325008972458, 8529548151905168943712409480648976478
        let round_constants = vec![vec![0;127], to_binary(60830615133950554781816095544784746916, block), to_binary(123974209842762307096225067893741045796, block), to_binary(135753353596758349485516658254368525747, block), to_binary(2939595398576264087850956589342439304, block),
           to_binary(40076352750431212541803900149960257548, block), to_binary(93852482691172964849160854953085040497, block), to_binary(73054168740293751893382319070945114008, block), to_binary(144789746567824501222915256981756980652, block),
           to_binary(59036272182462320228333616846778978649, block), to_binary(166439991022674764481604851805671696717, block), to_binary(64091962405798025994984400729877468973, block), to_binary(8950317157704596166529150362709421344, block),
           to_binary(28795834160692336853030883568187811345, block), to_binary(137915742661053200982257724694012736541, block), to_binary(86085925939554565779417794353904662176, block), to_binary(23288358310028615539116789380099884810, block),
           to_binary(165981077950982094502239969905075428928, block), to_binary(4469287351800280448126894826667641959, block), to_binary(888278832978011390558589191095311509, block), to_binary(123576576783312288673553204116526681366, block),
           to_binary(38579962837753657712628810806406624638, block), to_binary(7478510915411686125285526311256515365, block), to_binary(47919742180966932354471811295519267460, block), to_binary(142347171677650656168600537099065620459, block),
           to_binary(105465968464268156221336769206667608062, block), to_binary(166464775595544809388951462027615614390, block), to_binary(137233817427539608459093273965615148811, block), to_binary(44777913530343219558122532298784153232, block),
           to_binary(94475522280157304513405905985442894506, block), to_binary(78575530189542675168336177243931529836, block), to_binary(115001994014445856801177509366837033576, block), to_binary(59429935103375028870050059594174275954, block),
           to_binary(20346381335678829430384832000907868512, block), to_binary(11237619622190469976409742019793615286, block), to_binary(151140273109080355090712990319289701265, block), to_binary(93702753531267315032829931483592140707, block),
           to_binary(58777198280635264403352853681873754441, block), to_binary(151586869306501686780863393969097636077, block), to_binary(156710783721481112692276585985340770102, block), to_binary(120056016483253930210671541690868977863, block),
           to_binary(156887814104095280194399769496450268073, block), to_binary(146768835735757528552066223178033184782, block), to_binary(65624804534009978967830519884494217981, block), to_binary(436125201163551063098589517560187809, block),
           to_binary(109800002567224400418779846336130677477, block), to_binary(83513827187087678177766363430713870527, block), to_binary(132988609336594686344463556093200414537, block), to_binary(142366609295053440692582788970203749744, block),
           to_binary(109387684609525752799508021957504570466, block), to_binary(20933172057947839459182393216063960978, block), to_binary(157323792536550539118094368367362870082, block), to_binary(145677098552381657304860012383218055267, block),
           to_binary(66784356843727874345536747980169357806, block), to_binary(164948109270748232225299160763320039218, block), to_binary(51438652122929605347730032519583036044, block), to_binary(62212925368486723456904506863637394704, block),
           to_binary(77062683975205218952024654251715634120, block), to_binary(144781915490232917836800052687357489309, block), to_binary(95379270850067906396539125244481076798, block), to_binary(111359025990301004509455750186474327590, block),
           to_binary(77390411713043003458557036104010645069, block), to_binary(97887147215960387433298055563163774892, block), to_binary(120905281723079439403682204698227350328, block), to_binary(137463780365100262676644052361004290476, block),
           to_binary(74901688219653535235259385966176528537, block), to_binary(139523595055809961167957783873928607384, block), to_binary(137372463640221908986201541074832293262, block), to_binary(156840293697636280672410303577981468250, block),
           to_binary(138066564216439861192551603930676022704, block), to_binary(164168867156173857990648020402791554099, block), to_binary(97479537262841041034787751216352008294, block), to_binary(66945230408801357834244322471887444053, block),
           to_binary(152442893795360537653719156412267908117, block), to_binary(12292790713563221531272411065878531353, block), to_binary(134375040760238427936311675753868485332, block), to_binary(149592608250844774105720014502350027851, block),
           to_binary(12319566215008486035364907927680778391, block), to_binary(158711805550223450233018026255709118815, block), to_binary(84020431617253616172384297325008972458, block), to_binary(8529548151905168943712409480648976478, block)];
        let cipher = MiMC::with_round_constants(block, &round_constants);
        // Plaintext 120727767513225448254489485179714792555, key 39228315104586972915198658082063443465, ciphertext 77425370965213627560640382505874246573
        assert_eq!(cipher.encrypt(&to_binary(120727767513225448254489485179714792555, block), &to_binary(39228315104586972915198658082063443465, block)), to_binary(77425370965213627560640382505874246573, block));

    }
}
